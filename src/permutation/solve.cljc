(ns permutation.solve
  (:require [permutation.kernel :as kernel]
            [permutation.words :as word]))

(defn- multiply
  [g h]
  [(kernel/multiply (first g) (first h)) (word/multiply (second g) (second h))])

(defn- inverse
  [g]
  [(kernel/inverse (first g)) (word/inverse (second g))])

(defn- identity-for
  [g]
  [(kernel/identity-for (first g)) (word/identity-for (second g))])

(defn- identity?
  [g]
  (kernel/identity? (first g)))

(defn elements-generated-by
  "produces all elements generated by generators"
  ([pgens names]
   (let [wgens (map #(vec [[%, 1]]) names)
         gens (map vector pgens wgens)]
     (loop [elements []
            visit [(identity-for (first gens))]]
       (if (empty? visit)
         elements
         (let [current (first visit)
               next-elements (conj elements current)
               neighbours (map #(multiply % current) gens)
               candidates (vec (concat (rest visit) neighbours))
               to-elements #(first %)
               pnext-elements (set (map to-elements next-elements))
               next-visit (filter #(not (pnext-elements (first %))) candidates)]
           (recur next-elements next-visit)))))))

(defn solve
  "solves for a states given generators and generator names"
  [pgens wgens state]
  (let [elements (elements-generated-by pgens wgens)
        matches (filter #(= (first %) state) elements)]
    (if-let [match (first matches)]
      (word/inverse (second match))
      "unsolvable")))
